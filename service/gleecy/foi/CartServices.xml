<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

<!--
General Order Placement and eCommerce Usage

| create customer | PartyServices.create#Account |
| create/update/delete customer address | ContactServices.create#PostalAddress, .update#PartyPostalAddress |
| create/update/delete customer phone | ContactServices.create#TelecomNumber, .update#PartyTelecomNumber |
| create/update/delete customer credit card | PaymentMethodServices.create#CreditCard, .update#CreditCard |

| login: merge with previous open | merge#OrderItems |

| init cart (auto on add to cart) | create#Order |
| add to cart                     | add#OrderProductQuantity, create#OrderItem |
| change cart quantity            | update#OrderProductQuantity, update#OrderItem |
| remove from cart                | delete#OrderItem |
| set billing and shipping info   | set#OrderBillingShippingInfo |
| split order                     | create#OrderPart |
| confirm/complete order          | place#Order |

| create order from shopping list (or other existing order) | clone#Order |

-->

    <service verb="interface" noun="OrderInfo">
        <out-parameters>
            <parameter name="orderHeader" type="Map"><auto-parameters entity-name="mantle.order.OrderHeader"/></parameter>
            <parameter name="orderPart" type="Map"><auto-parameters entity-name="mantle.order.OrderPart"/></parameter>
            <parameter name="orderPromoCodeDetailList" type="List"><parameter name="orderPromoCode" type="Map"/></parameter>

            <parameter name="orderItemList" type="List">
                <parameter name="orderItem" type="Map">
                    <auto-parameters entity-name="mantle.order.OrderItem"/>
                    <parameter name="productName" />
                    <parameter name="features" type="Map" />
                </parameter>
            </parameter>
            <parameter name="orderItemWithChildrenSet" type="Set"><parameter name="orderItemSeqId"/></parameter>

            <parameter name="paymentInfoList" type="List"><parameter name="partPaymentInfo" type="Map">
                <parameter name="payment" type="Map"><auto-parameters entity-name="mantle.account.payment.Payment"/></parameter>
                <parameter name="statusItem" type="Map"><auto-parameters entity-name="moqui.basic.StatusItem"/></parameter>
                <parameter name="paymentMethod" type="Map"><auto-parameters entity-name="mantle.account.method.PaymentMethod"/></parameter>
                <parameter name="creditCard" type="Map"><auto-parameters entity-name="mantle.account.method.CreditCard"/></parameter>
                <parameter name="creditCardTypeEnum" type="Map"><auto-parameters entity-name="moqui.basic.Enumeration"/></parameter>
                <parameter name="maskedCardNumber"/>
                <parameter name="postalAddress" type="Map"><auto-parameters entity-name="mantle.party.contact.PostalAddress"/></parameter>
                <parameter name="postalAddressStateGeo" type="Map"><auto-parameters entity-name="moqui.basic.Geo"/></parameter>
                <parameter name="telecomNumber" type="Map"><auto-parameters entity-name="mantle.party.contact.TelecomNumber"/></parameter>
                <parameter name="paymentMethodTypeEnum" type="Map"><auto-parameters entity-name="moqui.basic.Enumeration"/></parameter>
                <parameter name="paymentInstrumentEnum" type="Map"><auto-parameters entity-name="moqui.basic.Enumeration"/></parameter>
            </parameter></parameter>
            <parameter name="paymentsTotal" type="BigDecimal"/>
            <parameter name="totalUnpaid" type="BigDecimal"/>

            <parameter name="postalAddress" type="Map">
                <auto-parameters entity-name="mantle.party.contact.PostalAddress"/></parameter>
            <parameter name="postalAddressStateGeo" type="Map">
                <auto-parameters entity-name="moqui.basic.Geo"/></parameter>
            <parameter name="telecomNumber" type="Map">
                <auto-parameters entity-name="mantle.party.contact.TelecomNumber"/></parameter>
        </out-parameters>
    </service>
    <service verb="get" noun="CartInfo">
        <description>Get information for current cart order (cartOrderId managed server side)</description>
        <implements service="gleecy.foi.CartServices.interface#OrderInfo"/>
        <actions>
            <service-call name="gleecy.foi.CartServices.get#ActiveOrderAndCustomer" out-map="context"/>
            <if condition="!cartOrderId"><return/></if>
            <service-call name="gleecy.foi.CartServices.get#OrderInfoInternal" in-map="[orderId:cartOrderId]" out-map="context"/>
        </actions>
    </service>
    <service verb="get" noun="OrderInfo">
        <description>Get information for a specific order, must be associated with active customer</description>
        <implements service="gleecy.foi.CartServices.interface#OrderInfo"/>
        <in-parameters>
            <parameter name="orderId" required="true"/>
        </in-parameters>
        <actions>
            <service-call name="gleecy.foi.CartServices.get#ActiveOrderAndCustomer" out-map="context"/>
            <if condition="!customerPartyId"><return message="No active customer, cannot view order" public="true" type="danger"/></if>

            <entity-find entity-name="OrderPart" list="orderPartList">
                <econdition field-name="orderId"/><econdition field-name="customerPartyId"/></entity-find>
            <if condition="!orderPartList"><return message="Order ${orderId} not found or not owned by active customer" public="true" type="danger"/></if>

            <service-call name="gleecy.foi.CartServices.get#OrderInfoInternal" in-map="[orderId:orderId]" out-map="context"/>
        </actions>
    </service>
    <service verb="get" noun="RelatedOrderItems">
        <description>Internal service to get related order items of given OrderHeader</description>
        <in-parameters>
            <parameter name="orderHeader" type="EntityValue" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="orderItemList" type="List">
                <parameter name="orderItem" type="Map">
                    <auto-parameters entity-name="mantle.order.OrderItem"/>
                    <parameter name="productName" />
                    <parameter name="feature" type="Map" />
                </parameter>
            </parameter>
            <parameter name="orderItemWithChildrenSet" type="Set"><parameter name="orderItemSeqId"/></parameter>
        </out-parameters>
        <actions>
            <entity-find-related value-field="orderHeader" relationship-name="mantle.order.OrderItem"
                                 list="eItemList" order-by-list="['orderItemSeqId']"/>
            <script><![CDATA[
                orderItemWithChildrenSet = new HashSet()
                List reverseList = eItemList.cloneList().orderByFields(["-orderItemSeqId"])
                for (orderItem in reverseList) {
                    if (orderItem.parentItemSeqId) {
                        orderItemWithChildrenSet.add(orderItem.parentItemSeqId)
                        eItemList.move(eItemList.indexMatching([orderItemSeqId:orderItem.orderItemSeqId]),
                                eItemList.indexMatching([orderItemSeqId:orderItem.parentItemSeqId])+1)
                    }
                }
            ]]></script>

            <set field="orderItemList" from="[]" />
            <iterate list="eItemList" entry="eItem" >
                <entity-find-one entity-name="mantle.product.Product" value-field="orderProduct" for-update="false" cache="true" auto-field-map="[productId:eItem.productId]" />
                <entity-find entity-name="mantle.product.feature.ProductFeatureAppl" cache="true" for-update="false" list="appls">
                    <econdition field-name="productId" from="eItem.productId" />
                    <econdition field-name="applTypeEnumId" value="PfatDistinguishing" />
                    <date-filter />
                </entity-find>
                <script><![CDATA[
                    Map orderItem = eItem.getMap()
                    orderItem.put("productPseudoId", orderProduct.pseudoId)
                    orderItem.put("productName", orderProduct.productName)
                    for(EntityValue appl in appls) {
                        EntityValue eFeature = ec.entity.fastFindOne("mantle.product.feature.ProductFeature", true, false, appl.productFeatureId)
                        Map feature = eFeature.getMap()
                        EntityValue featureType = ec.entity.fastFindOne("moqui.basic.Enumeration", true, false, feature.productFeatureTypeEnumId)
                        feature.put("featureTypeDescription", featureType.description)
                        orderItem.put(featureType.enumId, feature)
                    }
                    orderItemList.add(orderItem)
                ]]></script>
            </iterate>
        </actions>
    </service>
    <service verb="get" noun="OrderInfoInternal">
        <description>Internal service to get order info (for cart or order history);
            get#CartInfo restricts to server side managed cartOrderId; get#OrderInfo restricts by active customerPartyId</description>
        <implements service="gleecy.foi.CartServices.interface#OrderInfo"/>
        <in-parameters>
            <parameter name="orderId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader"/>
            <if condition="orderHeader == null"><return message="Order not found with ID ${orderId}" public="true" type="danger"/></if>

            <entity-find-related value-field="orderHeader" relationship-name="mantle.order.OrderPart" list="orderPartList"/>
            <set field="orderPart" from="orderPartList ? orderPartList[0] : null"/>

            <!-- get orderPromoCodeDetailList -->
            <entity-find entity-name="mantle.product.store.OrderPromoCodeDetail" list="orderPromoCodeDetailList">
                <econdition field-name="orderId"/></entity-find>

            <entity-find-related value-field="orderHeader" relationship-name="mantle.order.OrderItem"
                                 list="eItemList" order-by-list="['orderItemSeqId']"/>
            <script><![CDATA[
                orderItemWithChildrenSet = new HashSet()
                List reverseList = eItemList.cloneList().orderByFields(["-orderItemSeqId"])
                for (orderItem in reverseList) {
                    if (orderItem.parentItemSeqId) {
                        orderItemWithChildrenSet.add(orderItem.parentItemSeqId)
                        eItemList.move(eItemList.indexMatching([orderItemSeqId:orderItem.orderItemSeqId]),
                                eItemList.indexMatching([orderItemSeqId:orderItem.parentItemSeqId])+1)
                    }
                }
            ]]></script>

            <set field="orderItemList" from="[]" />
            <iterate list="eItemList" entry="eItem" >
                <entity-find-one entity-name="mantle.product.Product" value-field="orderProduct" for-update="false" cache="true" auto-field-map="[productId:eItem.productId]" />
                <entity-find entity-name="mantle.product.feature.ProductFeatureAppl" cache="true" for-update="false" list="appls">
                    <econdition field-name="productId" from="eItem.productId" />
                    <econdition field-name="applTypeEnumId" value="PfatDistinguishing" />
                    <date-filter />
                </entity-find>
                <script><![CDATA[
                    Map orderItem = eItem.getMap()
                    orderItem.put("productPseudoId", orderProduct.pseudoId)
                    orderItem.put("productName", orderProduct.productName)
                    Map features = new HashMap()
                    for(EntityValue appl in appls) {
                        EntityValue eFeature = ec.entity.fastFindOne("mantle.product.feature.ProductFeature", true, false, appl.productFeatureId)
                        Map feature = eFeature.getMap()
                        EntityValue featureType = ec.entity.fastFindOne("moqui.basic.Enumeration", true, false, feature.productFeatureTypeEnumId)
                        feature.put("featureTypeDescription", featureType.description)
                        features.put(featureType.enumId, feature)
                    }
                    orderItem.put("features", features)
                    orderItemList.add(orderItem)
                ]]></script>
            </iterate>
            <!-- get paymentList -->
            <entity-find-related value-field="orderHeader" relationship-name="mantle.account.payment.Payment"
                    list="paymentList" order-by-list="['paymentId']"/>
            <!--
            Gleecy: Why is only CreditCard?
            <set field="paymentList"
                 from="paymentList.findAll{ it.method.paymentMethodTypeEnumId == 'PmtCreditCard'}"/>
            -->
            <script><![CDATA[
                import org.moqui.entity.EntityList
                import org.moqui.entity.EntityValue

                paymentInfoList = []
                paymentsTotal = 0.0
                for (EntityValue payment in paymentList) {
                    if (!(((String) payment.statusId) in ['PmntCancelled', 'PmntVoid', 'PmntDeclined']))
                        paymentsTotal += (payment.amount ?: 0)
                    Map paymentInfo = [payment:payment, statusItem:payment.status]
                    EntityValue paymentMethod = (EntityValue) payment.method
                    if (paymentMethod != null) {
                        paymentInfo.paymentMethod = paymentMethod
                        paymentInfo.postalAddress = paymentMethod.PostalAddress
                        paymentInfo.postalAddressStateGeo = paymentInfo.postalAddress?."StateProvince#moqui.basic.Geo"
                        paymentInfo.telecomNumber = paymentMethod.TelecomNumber
                        paymentInfo.paymentMethodTypeEnum = paymentMethod.methodType

                        creditCard = paymentMethod.creditCard
                        if (creditCard) {
                            paymentInfo.creditCard = creditCard.getMap().remove("cardNumber")
                            paymentInfo.creditCardTypeEnum = creditCard?.type
                            cardNumber = creditCard.cardNumber
                            paymentInfo.maskedCardNumber = cardNumber ? '*'.padRight(cardNumber.length() - 4, '*') + cardNumber.substring(cardNumber.length() - 4, cardNumber.length()) : ''
                        }
                        paymentInfo.payPalAccount = paymentMethod.payPalAccount
                    }
                    paymentInfo.paymentInstrumentEnum = payment.instrument
                    paymentInfoList.add(paymentInfo)
                }
                totalUnpaid = (orderPart.partTotal ?: 0.0) - (paymentsTotal ?: 0.0)

                postalAddress = (EntityValue) orderPart.'mantle.party.contact.PostalAddress'
                postalAddressStateGeo = (EntityValue) postalAddress?."StateProvince#moqui.basic.Geo"
                telecomNumber = (EntityValue) orderPart.'mantle.party.contact.TelecomNumber'
            ]]></script>
        </actions>
    </service>
    <service verb="get" noun="CustomerOrders">
        <!-- TODO: handle pagination -->
        <out-parameters>
            <parameter name="orderInfoList" type="List"><parameter name="orderInfo" type="Map"/></parameter>
        </out-parameters>
        <actions>
            <service-call name="gleecy.foi.CartServices.get#ActiveOrderAndCustomer" out-map="context"/>
            <if condition="!customerPartyId"><return message="No active customer, cannot get orders" public="true" type="warning"/></if>

            <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList">
                <econdition field-name="customerPartyId"/>
                <order-by field-name="-entryDate"/>
            </entity-find>
            <set field="orderInfoList" from="[]"/>
            <iterate list="existingOrderList" entry="existingOrder">
                <script>orderInfoList.add(existingOrder.getMap())</script>
            </iterate>
        </actions>
    </service>

    <service verb="add" noun="OrderPromoCode">
        <in-parameters>
            <parameter name="cartOrderId" />
            <parameter name="promoCode" />
        </in-parameters>
        <actions>
            <service-call name="mantle.product.PromotionServices.add#OrderPromoCode" in-map="[orderId:cartOrderId, promoCode:promoCode]"/>
        </actions>
    </service>

    <service verb="add" noun="Product" >
        <implements service="gleecy.foi.CartServices.get#CartInfo"/>
        <in-parameters>
            <parameter name="productStoreId" required="true"/>
            <parameter name="productId" required="true"/>
            <parameter name="quantity" type="BigDecimal" default="1.0"/>
            <parameter name="currencyUomId"/>
            <parameter name="productStoreId"/>
        </in-parameters>
        <actions>
            <!-- NOTE: use the web session for attributes such as cartOrderId for security; this won't work in a stateless mode or outside a web session -->
            <set field="carrierPartyId" from="'_NA_'"/>
            <set field="shipmentMethodEnumId" from="'ShMthGround'"/>

            <service-call name="gleecy.foi.CartServices.get#ActiveOrderAndCustomer" out-map="context"/>
            <set field="orderId" from="cartOrderId"/>
            <set field="defaultOrderParameters" from="[salesChannelEnumId:'ScWeb']" />
            <service-call name="mantle.order.OrderServices.add#OrderProductQuantity" in-map="context + defaultOrderParameters" out-map="addOut"/>
            <!--<script>
                ec.web.session.setAttribute('cartOrderId', addOut.orderId)
            </script>-->
            <set field="sessionAttributes" from="ec.web.sessionAttributes"/>
            <set field="sessionAttributes.cartOrderId" from="addOut.orderId"/>

            <service-call name="gleecy.foi.CartServices.get#CartInfo" out-map="context"/>
        </actions>
    </service>

    <service verb="update" noun="OrderProductQuantity" >
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderItemSeqId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
        </in-parameters>
        <actions>

           <if condition="quantity == 0">
                <service-call name="gleecy.foi.CartServices.delete#OrderItem"
                    in-map="[orderId:orderId, orderItemSeqId:orderItemSeqId]"/>
                <else>
                    <service-call name="mantle.order.OrderServices.update#OrderItem"
                        in-map="[orderId:orderId, orderItemSeqId:orderItemSeqId, quantity:quantity]"/>
                </else>
            </if>
        </actions>
    </service>

    <service verb="delete" noun="OrderItem" >
        <in-parameters>
            <parameter name="orderId" />
            <parameter name="orderItemSeqId" />
        </in-parameters>
        <actions>
            <service-call name="mantle.order.OrderServices.delete#OrderItem"
                        in-map="[orderId:orderId, orderItemSeqId:orderItemSeqId]"/>
        </actions>
    </service>

    <service verb="get" noun="ShippingOptions">
        <out-parameters>
            <parameter name="shippingOptions"/>
        </out-parameters>
        <actions>
            <service-call name="gleecy.foi.CartServices.get#ActiveOrderAndCustomer" out-map="context"/>
            <if condition="!cartOrderId"><return message="Cart is empty" public="true" type="warning"/></if>

            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader">
            <field-map field-name="orderId" from="cartOrderId"/></entity-find-one>
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart">
                <field-map field-name="orderId" from="cartOrderId"/></entity-find-one>

            <service-call name="mantle.party.ContactServices.get#PartyContactInfoList" out-map="shippingContactListInfo"
                in-map="[partyId:customerPartyId, postalContactMechPurposeId:'PostalShippingDest',
                    telecomContactMechPurposeId:'PhoneShippingDest']"/>

            <service-call name="mantle.product.StoreServices.get#StoreShippingOptions" in-map="[productStoreId:productStoreId, orderId:cartOrderId, orderPartSeqId:orderPart.orderPartSeqId,postalContactMechId:shippingContactListInfo.postalAddressList?.first?.postalContactMechId, getRates:true]" out-map="context"/>
        </actions>
    </service>
    <service verb="set" noun="BillingShippingInfo">
        <in-parameters>
            <parameter name="orderPartSeqId"/>

            <parameter name="paymentId"><description>Specify when there is more than one Payment per order;
                is checked server side to make sure associated with order</description></parameter>
            <parameter name="paymentInstrumentEnumId"/>
            <parameter name="paymentMethodId"/>
            <parameter name="finAccountId"/>

            <parameter name="shippingPostalContactMechId"/>
            <parameter name="shippingTelecomContactMechId"/>
            <parameter name="carrierAndShipmentMethod"/>
            <parameter name="carrierPartyId"/>
            <parameter name="shipmentMethodEnumId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="paymentId"/>
            <parameter name="partyId"/>
            <parameter name="password"/>
        </out-parameters>
        <actions>
            <service-call name="gleecy.foi.CartServices.get#ActiveOrderAndCustomer" out-map="context"/>
            <if condition="!cartOrderId"><return message="Cart is empty" public="true" type="warning"/></if>
            <set field="orderId" from="cartOrderId"/>

            <!--TODO: if no customerPartyId call service to create one now and set in session (no user account aka 'anonymous') -->

            <service-call name="mantle.order.OrderServices.set#OrderBillingShippingInfo" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="place" noun="CartOrder">
        <implements service="gleecy.foi.CartServices.interface#OrderInfo"/>
        <in-parameters>
            <parameter name="cardSecurityCodeByPaymentId" type="Map"/>
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId"/>
            <parameter name="statusChanged" type="Boolean"/>
        </out-parameters>
        <actions>
            <service-call name="gleecy.foi.CartServices.get#ActiveOrderAndCustomer" out-map="context"/>
            <if condition="!cartOrderId"><return message="Cart is empty" public="true" type="warning"/></if>
            <set field="orderId" from="cartOrderId"/>

            <!-- TODO: check shipping and payment info -->
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader">
                <field-map field-name="orderId"/>
            </entity-find-one>

            <!-- authorize CC/etc payment(s), calling place#Order will trigger this, but do in advance to better support CC edits before placed -->
            <service-call name="mantle.account.PaymentServices.authorize#OrderPayments" in-map="context" out-map="authResult"/>
            <!-- if any don't authorize return message here... or optionally allow place anyway? -->
            <if condition="authResult.authFailed"><return message="Payment authorize failed" public="true" type="danger"/></if>

            <!-- Validate if the orderHeader.grandTotal is different from total authorized payment.Amount for the CC, this in order to avoid not making a proper charge-->
            <if condition="orderHeader.grandTotal != authResult.totalAuthorized">
                <return message="Payment authorize failed" public="true" type="danger"/>
                <log level="error" message="Authorize Payment failed because total order (${orderHeader.grandTotal}) is different to authorize amount (${authResult.totalAuthorized})"/>
            </if>

            <!-- place order -->
            <service-call name="mantle.order.OrderServices.place#Order" in-map="[orderId:orderId]" out-map="context"/>
            <!-- get order info to return for confirmation -->
            <service-call name="gleecy.foi.CartServices.get#OrderInfoInternal" in-map="[orderId:orderId]" out-map="context"/>
            <!-- if all is well we're done with this cart order -->
            <script>
                ec.web.sessionAttributes.remove("cartOrderId")
                ec.web.session.removeAttribute('cartOrderId', addOut.orderId)
            </script>

        </actions>
    </service>

    <service verb="get" noun="ActiveOrderAndCustomer">
        <description>Get active cart order, for internal (server-side) use only</description>
        <out-parameters>
            <parameter name="productStoreId"/>
            <parameter name="cartOrderId"/>
            <parameter name="customerPartyId"/>
        </out-parameters>
        <actions>
            <!-- NOTE: use the web session for attributes such as cartOrderId for security; this won't work in a stateless mode or outside a web session -->
            <set field="sessionAttributes" from="ec.web.sessionAttributes"/>
<!--            <set field="cartOrderId" from="ec.web.session.getAttribute('cartOrderId')"/>-->
            <set field="cartOrderId" from="sessionAttributes.cartOrderId"/>
            <log message="cartOrderId in session: ${cartOrderId}" />

            <set field="productStoreId" from="sessionAttributes.productStoreId"/>
            <!-- TODO: if no productStoreId lookup somehow? should be set from initial call to content/config.js transition -->

            <set field="customerPartyId" from="ec.user.userAccount?.partyId ?: sessionAttributes.customerPartyId"/>
            <set field="sessionAttributes.customerPartyId" from="customerPartyId"/>

            <if condition="!cartOrderId &amp;&amp; customerPartyId">
                <!-- see if there is an open order for user and get that ID into session -->
                <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList">
                    <econdition field-name="statusId" value="OrderOpen"/>
                    <econdition field-name="customerPartyId"/>
                    <select-field field-name="orderId"/><select-field field-name="orderPartSeqId"/>
                    <order-by field-name="-entryDate"/><!-- get most recent open order -->
                </entity-find>
                <if condition="existingOrderList">
                    <set field="cartOrderId" from="existingOrderList[0].orderId"/>
                    <set field="sessionAttributes.cartOrderId" from="cartOrderId"/>
                    <!--<script>
                        ec.web.session.setAttribute('cartOrderId', addOut.orderId)
                    </script>-->
                </if>
            </if>
        </actions>
    </service>
    <service verb="checkout" noun="CartOrder">
        <in-parameters>
            <parameter name="paymentSource" required="true" />
        </in-parameters>
        <out-parameters>
            <parameter name="paypalOrderId" />
            <parameter name="paymentGatewayResponseId"/>
            <parameter name="payment"/>
        </out-parameters>
        <actions>
            <service-call name="gleecy.foi.CartServices.get#ActiveOrderAndCustomer" out-map="context"/>
            <if condition="!cartOrderId"><return message="Cart is empty" public="true" type="warning"/></if>
            <set field="orderId" from="cartOrderId"/>

            <!-- TODO: check shipping and payment info -->
            <entity-find-one entity-name="mantle.order.OrderHeader" value-field="orderHeader">
                <field-map field-name="orderId"/>
            </entity-find-one>
            <if condition="!orderHeader" >
                <log level="error" message="Cart ID ${cartOrderId} is not found" />
                <return message="Cart ID ${cartOrderId} is not found" public="true" type="danger"/>
            </if>
            <entity-find-related value-field="orderHeader" relationship-name="parts" list="orderParts"/>
<!--            <entity-find entity-name="mantle.order.OrderPart" list="orderPartList">-->
<!--                <econdition field-name="orderId"/>-->
<!--                <select-field field-name="orderPartSeqId"/>-->
<!--                <order-by field-name="orderPartSeqId"/>-->
<!--            </entity-find>-->
            <set field="orderPart" from="orderParts.first" />
            <set field="orderPartSeqId" from="orderPart.orderPartSeqId"/>

            <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                <econdition field-name="orderId"/>
                <econdition field-name="statusId" operator="not-in" value="PmntCancelled,PmntVoid,PmntDeclined"/>
            </entity-find>
            <if condition="paymentList.size() &gt; 1" >
                <log level="error" message="More than 1 payments for single order " />
                <return message="More than 1 payments for single order" public="true" type="danger"/>
<!--                <iterate list="paymentList" entry="payment">-->
<!--                    <if condition="partPayment.statusId in ['PmntProposed', 'PmntPromised']">-->
<!--                        <then> <set field="payment" from="partPayment"/></then>-->
<!--                        <else> <set field="amount" from="amount - (partPayment.amount ?: 0)"/></else>-->
<!--                    </if>-->
<!--                </iterate>-->
            </if>
            <set field="payment" from="paymentList?.first" />

            <!-- 4. Create a Payment object and set payment in context -->
            <if condition="!payment" >
                <set field="toPartyId" from="orderPart.vendorPartyId" />
                <if condition="!toPartyId">
                    <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore" cache="true">
                        <select-field field-name="organizationPartyId"/>
                    </entity-find-one>
                    <set field="toPartyId" from="productStore.organizationPartyId" />
                </if>
                <if condition="paymentSource == 'paypal' || paymentSource == 'card' || paymentSource.paypal || paymentSource.card" >
                    <set field="paymentMethodTypeEnumId" value="PmtPayPalAccount" />
                    <else><set field="paymentMethodTypeEnumId" value="PmtOther" /></else>
                </if>
                <entity-find entity-name="mantle.account.method.PaymentMethod" cache="true" list="paymentMethods">
                    <econdition field-name="paymentMethodTypeEnumId" from="paymentMethodTypeEnumId" />
                </entity-find>
                <set field="toPaymentMethodId" from="paymentMethods?.first?.paymentMethodId" />

                <service-call name="mantle.order.OrderServices.add#OrderPartPayment"
                              in-map="context+[
                                orderId:orderId,
                                orderPartSeqId:orderPartSeqId,
                                statusId: 'PmntProposed',
                                toPaymentMethodId: toPaymentMethodId
                                ]" out-map="context" />
                <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" for-update="true" />
            </if>
            <!-- 5. Request PayPal to create a PayPal Order and return payPalOrderId and payment -->
            <if condition="payment.statusId in ['PmntProposed', 'PmntPromised']" ><then>
                <if condition="paymentSource == 'paypal' || paymentSource == 'card' || paymentSource.paypal || paymentSource.card" >
                    <then>
<!--                        <set field="paymentSrcMap" from="[paypal:[:]]" /> paymentSource: paymentSrcMap,-->
                        <service-call name="gleecy.foi.PayPalServices.submit#Payment" out-map="context"
                                    in-map="context + [
                                    path: '/v2/checkout/orders/',
                                    intent: 'AUTHORIZE',
                                    newStatus: 'PmntPromised',
                                    payment: payment
                                    ]"/>
                    </then>
                    <!-- TODO: support other payment methods:
                    <else-if condition="OTHER PAYMENT METHOD"></else-if>
                     -->
                </if>
            </then><else>
                <set field="paypalOrderId" from="payment.paymentAuthCode" />
            </else></if>
        </actions>
    </service>
    <service verb="checkout" noun="OrderPart">
        <in-parameters>
            <parameter name="orderId" required="true" />
            <parameter name="toPaymentMethodId" required="true" />
            <parameter name="paymentMethodId" />
            <parameter name="statusId" default-value="PmntProposed"/>
            <parameter name="effectiveDate" type="Timestamp"><description>No default value, allow null until effectiveDate known, must be set before Delivered status</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="payment" />
            <parameter name="payPalOrderId" />
        </out-parameters>
        <actions>
            <!-- 1. Get OrderPart from orderID -->
            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" />
            <!-- 2. If Order information is not valid, return Error -->
            <if condition="!orderPart">
                <return error="true" type="info" message="Order ${orderId}, order part ${orderPartSeqId} is not found"/>
            </if>
            <if condition="orderPart.validThurDate.before(ec.user.nowTimeStamp)" >
                <return error="true" type="info" message="Order ${orderId}, order part ${orderPartSeqId} is expired"/>
            </if>
            <if condition="!orderPart.customerPartyId || orderPart.vendorPartyId" >
                <return error="true" type="info" message="Order ${orderId}, order part ${orderPartSeqId}: Customer and/or vendor information is missing."/>
            </if>

            <set field="amount" from="orderPart.partTotal" />
            <!-- 3. Search for existing payment -->
            <entity-find entity-name="mantle.account.payment.Payment" list="partPaymentList">
                <econdition field-name="orderId"/>
                <econdition field-name="orderPartSeqId"/>
                <econdition field-name="statusId" operator="not-in" value="PmntCancelled,PmntVoid,PmntDeclined"/>
            </entity-find>
            <if condition="partPaymentList.size() &gt;= 1" >
                <log level="warn" message="More than 1 payments for single order part" />
                <iterate list="partPaymentList" entry="partPayment">
                    <if condition="partPayment.statusId in ['PmntProposed', 'PmntPromised']">
                        <then> <set field="payment" from="partPayment"/></then>
                        <else> <set field="amount" from="amount - (partPayment.amount ?: 0)"/></else>
                    </if>
                </iterate>
            </if>

            <!-- 4. Create a Payment object and set payment in context -->
            <if condition="!payment" >
                <service-call name="mantle.account.PaymentServices.create#Payment" out-map="context"
                              in-map="context + [
                                paymentTypeEnumId: 'PtOrderPref',
                                fromPartyId:orderPart.vendorPartyId,
                                toPartyId:toPartyId.customerPartyId,
                                statusId: 'PmntProposed',
                                amount: amount
                                ]" />
                <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" for-update="true" />
            </if>
            <!-- 5. Request PayPal to create a PayPal Order and return payPalOrderId and payment -->
            <service-call name="gleecy.foi.PayPalServices.submit#Payment" out-map="context"
                          in-map="context + [
                path: '/v2/checkout/orders/',
                intent: 'AUTHORIZE',
                newStatus: 'PmntPromised']"/>
        </actions>
    </service>
</services>
